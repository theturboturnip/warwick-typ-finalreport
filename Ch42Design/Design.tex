% !TEX root =  ../FinalReport.tex

\chapter{Design}
\label{sec:Design} 

\section{Command-Line Interface}
The compiled binary uses a command-line interface to configure and run one of many subcommands available.
These subcommands are:\label{sec:DesignSubcommands}
\begin{itemize}
    \item \texttt{makeinput}, which generates simulation input files, fulfilling \cref{req:GenerateState}.
    \item \texttt{fixedtime}, which runs a headless simulation for a fixed time, fulfilling \cref{req:HeadlessSim}.
    \item \texttt{compare}, which compares two simulation states for equality, fulfilling \cref{req:Compare}.
    \item \texttt{renderppm}, which visualizes a simulation state in the same way the original ACA coursework did.
    \item \texttt{convert2newbinary}, for converting ACA simulation state files to a potential new format (see \cref{sec:FileFormat}). Currently a no-op.
    \item \texttt{run}, which starts a real-time visualized simulation, fulfilling \cref{req:VizSim}.
\end{itemize}
Splitting the program into subcommands was inspired by Git\cite{tool:Git}, and avoids creating separate binaries for each operation.
Each subcommand can be configured with command-line options conforming to POSIX standard\cite{IEEE2018UtilityConventions}.
Examples of using the program are in \cref{fig:BashExampleUsage}.
\input{FinalReport/Ch42Design/figures/usage_example}

\section{Generating Inputs}
The \texttt{makeinput} subcommand allows input simulation states to be generated from image files.
Each pixel of the input image represents a cell of the grid, including padding cells\footnote{This can allow the padding cells to be fluids rather than boundaries, which is incorrect. In the future this will be changed to add padding cells once the image is parsed.}, where non-black pixels are denoted as boundary cells and are fluid cells otherwise.
The example in \cref{fig:ExampleMakeinput} shows an example file which creates a rectangular obstacle, and the visualization of the generated state.
\input{FinalReport/Ch42Design/figures/example_makeinput}

Velocities and pressure in every cell are currently set to constant default values.
For velocities, this is \SI{1}{m/s} east, equal to the default flow of incoming fluid, which may cause issues with correctness.
An example would be a situation where fluid is occluded from the input direction by an obstacle, but moves east anyway with no reason to do so.
%it would not be correct for that fluid to move) 
This will likely be changed to zero out initial velocity, requiring some simulation to take place before the fluid begins to move.

The exact initial value of pressure is inconsequential as the simulation only cares about the difference between cells.
This means the only significant point is that the pressure is equal over all cells, so the system should be in equilibrium.
This may be inconsistent with the nonzero velocities mentioned above, which is another reason to zero them out instead.


\input{FinalReport/Ch42Design/Sub_FileFormat}

\section{Simulation Backends}
To allow easy comparisons between CPU and GPU simulations the program contains multiple simulation backends which can be requested when running a headless simulation\footnote{The realtime visualization currently only supports the CUDA-based backend, violating \cref{req:GPUCapable}.}.
The headless simulation uses a \texttt{--backend} command line option to allow the user to choose the backend from this selection:\label{sec:DesignBackends}
\begin{itemize}
    \item Null, a backend which does no simulation for testing purposes.
    \item CPU Simple, equivalent to pre-optimization ACA code.
    \item CPU Optimized, equivalent to the submission for ACA, bit-equivalent to CPU Simple.
    \item CPU Optimized Adapted, a version of CPU Optimized slightly modified to be closer to the GPU version.
    \item CUDA Backend V1, the only GPU-based backend.
\end{itemize}

Currently the only modification present in the CPU Optimized Adapted backend is the removal of double-precision floating point logic, which is not present on the GPU for speed concerns.
However once the GPU introduces residual checking for the iterative solver, or any other major changes to the pipeline, they will be introduced into this backend to ensure a like-for-like comparison.

\input{FinalReport/Ch42Design/Sub_VisualizationPipeline}

\section{Comparison Heuristics}
In the comparison subcommand heuristics are used to judge if one simulation is accurate and precise with respect to the other.
This does not quite fulfil \cref{req:CompareBinary}, as there are two results and two heuristics used instead of just one.
To fix this, it is planned that the comparison will produce \texttt{SIMILAR} if the simulations are both accurate and precise, and \texttt{NOT~SIMILAR} otherwise.
The program may then provide additional information to help the user determine the cause of the problem.

This assumes one of the supplied states is a known-valid simulation state, and the other is not.
Two simulation state files are provided, and the velocity and pressure values $u, v, p$ are compared separately.
The simulation states must be of the same resolution, and should use the same boundary squares (although this is not currently checked).

The comparison is performed by calculating the mean and standard deviation of the square error between the datasets.
These are then compared to tolerance values to produce two binary outputs: ACCURATE if the mean is below tolerance, and PRECISE if the standard deviation is below tolerance.
Examples are shown in \cref{fig:example_comparisons}.

The tolerance for the mean was derived from an expected error magnitude of $\pm 10^{-7}$, which was squared to produce $10^{-14}$.
It is assumed that the standard deviation should always be smaller than the mean, so the tolerance for standard deviation is also $10^{-14}$.
\todopending{More examination of this? Square error always >0 => if std.dev > mean then distribution cannot be normal? Prob wait for full report}

\input{FinalReport/Ch42Design/figures/example_comparisons}