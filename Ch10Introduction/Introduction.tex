% !TEX root =  ../FinalReport.tex

\chapter{Introduction}
\label{sec:Introduction} 
The development of equations and mathematical constructs that model natural phenomena has been a large research space for centuries.
As digital computers have developed, programs have been built to use these equations and find the results much faster than previously possible\cite{AtomicHeritageFoundationComputingProject}.
Computational Fluid Dynamics (CFD) programs are programs that simulate fluid flow in some form, usually using the Navier-Stokes equations (reproduced in \cref{eq:NavierStokesContinuity,eq:NavierStokesMomentum}).

These fluid simulations have a variety of uses,
including in aerodynamics\cite{jameson2002},%\todocite{AirShaper},%\todocite{https://www.plm.automation.siemens.com/global/en/industries/automotive-transportation/aerodynamics.html}
fire spread modelling\cite{Sullivan_2009},
and in the entertainment industry (albeit with a focus on artistic input rather than physical accuracy\cite{article:FluidDynamicsOnBigScreen}).

These cases generally do not require simulations at interactive speeds, except for those found in the games industry.
While the games industry does use fluid simulation\cite{paper:GameFluidSummary:medveckyreal}, many uses do not precisely integrate the Navier-Stokes equations but approximates them \cite{paper:StableFluids:10.1145/311535.311548} using a Lagrangian method.
An exception to this is \cite{presentation:RealtimeFluidSimTombRaider}, which uses a Jacobi solver for the Navier-Stokes equations. This is used to simulate character interaction with different substances floating on the water surface\cite{presentation:RealtimeFluidSimTombRaider}, not to simulate large blocks of water.
By and large, interactive speeds and precise simulation for large fields are not pursued together.

\section{Motivation}
The Advanced Computer Architecture coursework last year presented a fluid simulation and tasked the students with optimizing it for a 6-core Intel i5-8500 CPU\cite{modules:CS257Coursework}.
The original code ran very slowly, taking 80 seconds to simulate 10 seconds of time. % or 8x faster?
After optimizations, the code simulated 10 seconds of time in just 1.26 seconds, 64x faster than the original and 7.9x faster than real time.\cite{modules:aca257submission}

However the simulation purposefully limited itself in some aspects, such as iteration count for an equation solver, which prevented it from converging to an accurate solution for the test data.
Students were also explicitly prevented from accelerating the simulation using a GPU, which could have made it much faster as each simulation phase is embarrassingly parallel.

Another limitation was that the simulation state could only be visualized once the full simulation had completed,
instead of in real time, even though the final simulation was fast enough.
This made the results much more difficult to understand, especially for people who don't understand the underlying code or mathematics.

\section{Project Aims}
The first goal of this project has been to port the simulation to the GPU.
This has provided a large speedup, with potential to improve it farther (see \cref{sec:FutureOptimization}).
The next goals of the project are to exploit this speedup in two ways: to make the simulation more detailed by increasing both the accuracy of the solver and  the grid resolution; and to intuitively visualize the simulation in real time.
The GPU simulation has be implemented in CUDA, and the visualization will be rendered in real time using Vulkan (see \cref{sec:LibrarySelection}).

\section{Stakeholders}
The main stakeholders continue to be the researcher and the project supervisor.
They are both invested into the project due to their own personal interest, and in the case of the researcher the effect this project has on final year grades.
% Me
% Matt Leeke
% People who will use the simualtion?

